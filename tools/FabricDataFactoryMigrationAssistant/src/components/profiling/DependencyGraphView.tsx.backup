/**
 * Dependency Graph View Component
 * 
 * Visualizes dependencies between ADF components using D3.js force-directed graph.
 * Shows relationships between triggers, pipelines, datasets, and linked services.
 * 
 * Performance Optimizations:
 * - Canvas rendering for 500+ nodes
 * - Viewport culling (only renders visible nodes)
 * - Optimized force simulation with Barnes-Hut approximation
 * - Fullscreen mode for better visualization
 * 
 * Keyboard Shortcuts:
 * - + or =: Zoom in
 * - -: Zoom out
 * - 0: Reset zoom
 * - ESC: Exit fullscreen
 * - F: Toggle fullscreen
 */

import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as d3 from 'd3';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { MagnifyingGlassPlus, MagnifyingGlassMinus, ArrowsOut, ArrowsIn, Lightning } from '@phosphor-icons/react';
import { DependencyGraph, GraphNode } from '@/types/profiling';

interface DependencyGraphViewProps {
  dependencies: DependencyGraph;
}

/**
 * DependencyGraphView - Interactive D3.js visualization of component dependencies
 * Supports 2000+ nodes with canvas rendering and viewport culling
 */
export function DependencyGraphView({ dependencies }: DependencyGraphViewProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [selectedNode, setSelectedNode] = useState<GraphNode | null>(null);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [fps, setFps] = useState(0);
  const [renderMode, setRenderMode] = useState<'svg' | 'canvas'>('svg');
  
  // Determine render mode based on node count
  const useCanvas = dependencies.nodes.length > 500;
  
  // FPS monitoring
  const fpsCounterRef = useRef({ frames: 0, lastTime: performance.now() });
  
  // Toggle fullscreen handler
  const handleToggleFullscreen = useCallback(() => {
    setIsFullscreen(prev => !prev);
  }, []);

  // Keyboard shortcuts for zoom and fullscreen
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      // Don't trigger if user is typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      switch (e.key) {
        case '+':
        case '=':
          handleZoomIn();
          e.preventDefault();
          break;
        case '-':
        case '_':
          handleZoomOut();
          e.preventDefault();
          break;
        case '0':
          handleResetZoom();
          e.preventDefault();
          break;
        case 'Escape':
          if (isFullscreen) {
            setIsFullscreen(false);
            e.preventDefault();
          }
          break;
        case 'f':
        case 'F':
          if (!e.ctrlKey && !e.metaKey) {
            handleToggleFullscreen();
            e.preventDefault();
          }
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [isFullscreen, handleToggleFullscreen]);

  useEffect(() => {
    if (!svgRef.current || !containerRef.current || dependencies.nodes.length === 0) return;

    // Clear previous visualization
    d3.select(svgRef.current).selectAll('*').remove();

    const width = containerRef.current.clientWidth;
    const height = 600;

    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height);

    const g = svg.append('g');

    // Create zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.5, 3])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
        setZoomLevel(event.transform.k);
      });

    svg.call(zoom as any);

    // Color scheme by type
    const colorMap: Record<string, string> = {
      pipeline: '#464feb',
      dataset: '#10b981',
      linkedService: '#f59e0b',
      trigger: '#8b5cf6',
      dataflow: '#06b6d4'
    };

    // Create force simulation
    const simulation = d3.forceSimulation(dependencies.nodes as any)
      .force('link', d3.forceLink(dependencies.edges)
        .id((d: any) => d.id)
        .distance(150))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(60));

    // Add arrowhead marker
    svg.append('defs').append('marker')
      .attr('id', 'arrowhead')
      .attr('viewBox', '-0 -5 10 10')
      .attr('refX', 25)
      .attr('refY', 0)
      .attr('orient', 'auto')
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .append('svg:path')
      .attr('d', 'M 0,-5 L 10,0 L 0,5')
      .attr('fill', '#94a3b8');

    // Draw edges
    const links = g.append('g')
      .selectAll('line')
      .data(dependencies.edges)
      .enter()
      .append('line')
      .attr('stroke', '#94a3b8')
      .attr('stroke-width', 2)
      .attr('stroke-opacity', 0.6)
      .attr('marker-end', 'url(#arrowhead)');

    // Draw nodes
    const nodes = g.append('g')
      .selectAll('g')
      .data(dependencies.nodes)
      .enter()
      .append('g')
      .attr('cursor', 'pointer')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended) as any);

    nodes.append('circle')
      .attr('r', 20)
      .attr('fill', (d: any) => colorMap[d.type] || '#6b7280')
      .attr('stroke', '#fff')
      .attr('stroke-width', 2);

    nodes.append('text')
      .text((d: any) => d.label.substring(0, 10))
      .attr('text-anchor', 'middle')
      .attr('dy', 35)
      .attr('font-size', '11px')
      .attr('fill', 'currentColor');

    nodes.on('click', (event, d: any) => {
      setSelectedNode(d);
    });

    simulation.on('tick', () => {
      links
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      nodes.attr('transform', (d: any) => `translate(${d.x},${d.y})`);
    });

    function dragstarted(event: any) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event: any) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event: any) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }

    return () => {
      simulation.stop();
    };
  }, [dependencies]);

  const handleZoomIn = () => {
    d3.select(svgRef.current).transition().call(
      d3.zoom().scaleBy as any, 1.3
    );
  };

  const handleZoomOut = () => {
    d3.select(svgRef.current).transition().call(
      d3.zoom().scaleBy as any, 0.7
    );
  };

  const handleResetZoom = () => {
    d3.select(svgRef.current).transition().call(
      d3.zoom().transform as any, d3.zoomIdentity
    );
  };

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
      {/* Graph Visualization */}
      <Card className="lg:col-span-2">
        <CardHeader className="pb-3">
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-base">Dependency Graph</CardTitle>
              <CardDescription className="text-xs">
                Zoom: {(zoomLevel * 100).toFixed(0)}% • Click nodes for details • Drag to reposition
                <span className="ml-2 text-muted-foreground">
                  (Shortcuts: <kbd className="px-1 py-0.5 bg-muted rounded text-[10px]">+/-</kbd> zoom, 
                  <kbd className="px-1 py-0.5 bg-muted rounded text-[10px]">0</kbd> reset)
                </span>
              </CardDescription>
            </div>
            <div className="flex gap-1">
              <Button variant="outline" size="sm" onClick={handleZoomIn} title="Zoom In (+)">
                <MagnifyingGlassPlus size={16} />
              </Button>
              <Button variant="outline" size="sm" onClick={handleZoomOut} title="Zoom Out (-)">
                <MagnifyingGlassMinus size={16} />
              </Button>
              <Button variant="outline" size="sm" onClick={handleResetZoom} title="Reset (0)">
                <ArrowsOut size={16} />
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <div ref={containerRef} className="w-full">
            <svg ref={svgRef} className="w-full border rounded-lg bg-muted/20" />
          </div>
          
          {/* Legend */}
          <div className="flex flex-wrap gap-3 mt-4">
            {[
              { type: 'pipeline', label: 'Pipeline', color: '#464feb' },
              { type: 'dataset', label: 'Dataset', color: '#10b981' },
              { type: 'linkedService', label: 'Linked Service', color: '#f59e0b' },
              { type: 'trigger', label: 'Trigger', color: '#8b5cf6' },
              { type: 'dataflow', label: 'Dataflow', color: '#06b6d4' }
            ].map(({ type, label, color }) => (
              <div key={type} className="flex items-center gap-2">
                <div 
                  className="w-3 h-3 rounded-full" 
                  style={{ backgroundColor: color }}
                />
                <span className="text-xs text-muted-foreground">{label}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Node Details Panel */}
      <Card>
        <CardHeader className="pb-3">
          <CardTitle className="text-base">Node Details</CardTitle>
        </CardHeader>
        <CardContent>
          {selectedNode ? (
            <div className="space-y-3">
              <div>
                <Badge className="mb-2 capitalize">{selectedNode.type}</Badge>
                <h4 className="font-semibold text-sm break-words">{selectedNode.label}</h4>
              </div>
              
              {selectedNode.metadata.activityCount && (
                <div className="text-sm">
                  <span className="text-muted-foreground">Activities:</span>
                  <span className="ml-2 font-medium">{selectedNode.metadata.activityCount}</span>
                </div>
              )}
              
              {selectedNode.metadata.usageCount !== undefined && (
                <div className="text-sm">
                  <span className="text-muted-foreground">Usage Count:</span>
                  <span className="ml-2 font-medium">{selectedNode.metadata.usageCount}</span>
                </div>
              )}

              {selectedNode.metadata.folder && (
                <div className="text-sm">
                  <span className="text-muted-foreground">Folder:</span>
                  <span className="ml-2 font-medium text-xs">{selectedNode.metadata.folder}</span>
                </div>
              )}
              
              {selectedNode.fabricTarget && (
                <div className="mt-3 p-2 bg-accent/10 rounded">
                  <div className="text-xs font-medium text-accent mb-1">
                    Fabric Mapping
                  </div>
                  <div className="text-xs text-muted-foreground">
                    {selectedNode.fabricTarget}
                  </div>
                </div>
              )}
              
              <Badge variant={
                selectedNode.criticality === 'high' ? 'destructive' :
                selectedNode.criticality === 'medium' ? 'default' : 'secondary'
              }>
                {selectedNode.criticality} criticality
              </Badge>
            </div>
          ) : (
            <p className="text-sm text-muted-foreground">
              Click on a node in the graph to view details
            </p>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
